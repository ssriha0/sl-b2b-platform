////////////////////////////////////////////////////////////////////////
//
// Writer.java
//
// This file was generated by MapForce 2011sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import java.io.IOException;

import com.altova.text.ITextNode;

public class Writer
{
	java.io.Writer mOutput;
	StringBuffer mPendingSeparators = new StringBuffer ();
	boolean mNewlineAfterSegments = true;
    EDISettings mSettings;
	EDISemanticValidator mValidator;
	Parser.Action[] mErrorSettings;
	
	long mLine;
	long mPosition;
	long mLineStart;

	public ServiceChars getServiceChars() {
		return mSettings.getServiceChars();
	}

	public boolean getNewlineAfterSegments() {
		return mNewlineAfterSegments;
	}

	void setNewlineAfterSegments(boolean newline) {
		mNewlineAfterSegments = newline;
	}

	public Writer (java.io.Writer output, EDISettings settings, Parser.Action[] errorSettings) {
		mOutput = output;
        mSettings = settings;
		mValidator = new EDISemanticValidator( settings);
		mErrorSettings = errorSettings;
		
		mLine = 0;
		mLineStart = 0;
		mPosition = 0;
	}

	public void write (String s) throws IOException{
		if (s.length() == 0)
			return;

		if( getEDIKind() != EDISettings.EDIFixed )
		{
			String sepString = mPendingSeparators.toString();
			mOutput.write (sepString);
			checkNewLines(sepString);
			mPosition += sepString.length();
		}
		mOutput.write (s);
		mPosition += s.length();
		mPendingSeparators.setLength(0);
	}

	public void writePendingSeparators () throws IOException{
		String sepString = mPendingSeparators.toString();
		mOutput.write (sepString);
		checkNewLines( sepString);
		mPosition += sepString.length();
		mPendingSeparators.setLength(0);
	}

	private void checkNewLines( String s) {
		for( int i = 0; i < s.length(); i++)
		{
			if (s.charAt(i) == '\n' || (s.charAt(i) == '\r' && SafeCharAt(s, i+1) != '\n'))
			{
				mLine++;
				mLineStart = mPosition + i;
			}
		}
	}
	
	static private char SafeCharAt( String s, int index) {
		if( index < s.length() )
			return s.charAt(index);
		else
			return 0;
	}
	
    public short getEDIKind( ) {
        return mSettings.getStandard();
    }

	public void addSeparator (byte serviceChar) {
		if ( serviceChar == ServiceChars.None)
			return;
		mPendingSeparators.append (getServiceChars().getSeparator(serviceChar));
	}

	public void clearPendingSeparators (byte separator)	{
		while (mPendingSeparators.length() > 0 && mPendingSeparators.charAt(mPendingSeparators.length()-1) == getServiceChars().getSeparator(separator))
			mPendingSeparators.deleteCharAt(mPendingSeparators.length()-1); // gasp!
	}

	public void clearPendingSeparators ()	{
		mPendingSeparators.setLength(0);
	}
	
	public EDISemanticValidator getValidator() {
		return mValidator;
	}

	public void handleError (ITextNode node, Parser.ErrorType error, String message) {
		String location = node.getName();
		ITextNode parent = node.getParent();
		while (parent != null && parent.getName() != null && !parent.isNull())
		{
			location = parent.getName() + " / " + location;
			parent = parent.getParent();
		}
		
		String lineLoc = String.format( "Line %d column %d (offset 0x%x): ", getLine(), getColumn(), getPosition() );
		location = lineLoc + location;
		
		switch ( mErrorSettings[error.ordinal()] )
		{
		case Stop:
		{
			throw new com.altova.AltovaException (location + ": " + message);	
		}
		case ReportReject:
		case ReportAccept:
		{
			System.out.println("Warning: " + location + ": " + message);
		}
		break;
		case Ignore: break;
		}
	}
	
	public long getLine() {
		return mLine + 1;
	}
	
	public long getColumn() {
		return mPosition - mLineStart + 2;
	}
	
	public long getPosition() {
		return mPosition;
	}
}
